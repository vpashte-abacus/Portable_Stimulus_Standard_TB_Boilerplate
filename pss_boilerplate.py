# ---------------------------------------------------------------------------
# Copyright (C) 2024 Abacus Semiconductor Corporation
# All rights reserved.
#
# This source code is proprietary and confidential unless stated otherwise
# by an official license. Unauthorized use, distribution, or modification
# is strictly prohibited.
# ---------------------------------------------------------------------------





#----------------------------------------------------------------------------
# Portable Stimulus (PyVSC) + Verilator Boilerplate
# ---------------------------------------------------------------------------
# Why this file exists
# -------------------
# • Provides a single Python script that turns any Verilog/SV DUT into a
#   Portable Stimulus testbench with minimum manual effort.
# • All places that require design knowledge are marked with **TODO** so a new
#   engineer can focus only on DUT specific edits.
#
# Workflow
# --------
# 1. Place this file in the same directory as your RTL source files.
# 2. Fill in the CONFIGURATION section below.
# 3. Adapt the autogenerated C++ wrapper to match your DUT ports.
# 4. Implement the reference model inside `DriveDUTTransaction.body()`.
# 5. Run:  python3 pss_boilerplate.py
# ---------------------------------------------------------------------------




import os                           # File system queries and shell commands
import ctypes                       # C-FFI for calling the Verilated model
import vsc                          # PyVSC — Portable Stimulus library

# ---------------------------------------------------------------------------
# CONFIGURATION — update for *each* new design
# ---------------------------------------------------------------------------
DUT_TOP_MODULE_NAME      = "<replace_with_top_module>"   # TODO
RTL_SOURCE_FILE_LIST     = ["<replace_with_file>.v"]    # TODO, accept multiple
VERILATOR_BUILD_OPTIONS  = "-O2 -trace"                        # add "-trace" if needed
NUMBER_OF_RANDOM_TESTS   = 25                            # Random transactions run
CPP_WRAPPER_FILENAME     = "tb.cpp"                     # generated if absent

# ---------------------------------------------------------------------------
# STEP 1 • Build Verilated model 
# ---------------------------------------------------------------------------
object_directory = f"obj_dir/V{DUT_TOP_MODULE_NAME}"
if not os.path.exists(object_directory):
    print("[INFO] Building Verilated model…")

    # ---- C++ wrapper template ----------------------------------------
    # Edit the function `evaluate_dut` to reflect your DUT port list and
    # expected return signal. One call per transaction.
    cpp_wrapper_template = f"""
#include <verilated.h>
#include "V{DUT_TOP_MODULE_NAME}.h"

extern "C" {{
    static V{DUT_TOP_MODULE_NAME} *dut_ptr = nullptr;

    void init() {{
        dut_ptr = new V{DUT_TOP_MODULE_NAME};
    }}

    // TODO: adjust argument list and internal signal mapping
    uint32_t evaluate_dut(uint32_t input_operand_a,
                          uint32_t input_operand_b,
                          uint8_t  operation_select) {{
        dut_ptr->a   = input_operand_a;
        dut_ptr->b   = input_operand_b;
        dut_ptr->sel = operation_select;
        dut_ptr->eval();
        return dut_ptr->result;   // TODO: replace with actual output port
    }}

    void finish() {{
        dut_ptr->final();
    }}
}}
"""
    with open(CPP_WRAPPER_FILENAME, "w", encoding="utf-8") as cpp_file:
        cpp_file.write(cpp_wrapper_template)

    joined_sources = " ".join(RTL_SOURCE_FILE_LIST)
    build_command = (
        f"verilator -cc {joined_sources} {CPP_WRAPPER_FILENAME} "
        f"-exe {VERILATOR_BUILD_OPTIONS} -o sim")
    os.system(build_command)
    os.system(f"make -C obj_dir -f V{DUT_TOP_MODULE_NAME}.mk")
else:
    print("[INFO] Existing Verilated model detected — build skipped.")

# ---------------------------------------------------------------------------
# STEP 2 • Load the shared library and map function signatures
# ---------------------------------------------------------------------------
# Map ctypes types to C function signature
shared_object_path = f"./obj_dir/V{DUT_TOP_MODULE_NAME}__ALL.so"
shared_lib = ctypes.CDLL(shared_object_path)
shared_lib.init()   # instantiate model

# Map Python types to C signature — update if the wrapper signature changes
shared_lib.evaluate_dut.argtypes = [
    ctypes.c_uint32,  #input_operand_a
    ctypes.c_uint32,  #input_operand_b
    ctypes.c_uint8    #operation_select
]
shared_lib.evaluate_dut.restype = ctypes.c_uint32  # primary DUT result

# ---------------------------------------------------------------------------
# STEP 3 • Portable Stimulus action
# ---------------------------------------------------------------------------
@vsc.action
class DriveDUTTransaction(vsc.Action):
# Single randomised transaction that exercises the DUT.

    input_operand_a  = vsc.rand_uint32_t()
    input_operand_b  = vsc.rand_uint32_t()
    operation_select = vsc.rand_uint8_t()

    @vsc.constraint
    def legal_operation_range(self):
        self.operation_select < 2  # TODO: expand when DUT supports more ops

    def body(self):
        # Replace with design specific functional model.
        if self.operation_select == 0:
            expected_result = self.input_operand_a + self.input_operand_b
        else:
            expected_result = self.input_operand_a - self.input_operand_b

        # ---------------- DUT evaluation --------------------------------
        observed_result = shared_lib.evaluate_dut(
            self.input_operand_a,
            self.input_operand_b,
            self.operation_select)

        # ---------------- Immediate check -------------------------------
        assert observed_result == expected_result, (
            f"Mismatch  opSel={self.operation_select}  "
            f"expected={expected_result:#x}  observed={observed_result:#x}")

# ---------------------------------------------------------------------------
# STEP 4 • Simple activity loop — suitable for smoke testing
# ---------------------------------------------------------------------------
@vsc.activity
def run_randomised_test_suite():
    for _ in range(NUMBER_OF_RANDOM_TESTS):
        DriveDUTTransaction()

# ---------------------------------------------------------------------------
# STEP 5 • Run Portable Stimulus scenario
# ---------------------------------------------------------------------------
print("[INFO] Executing Portable Stimulus scenario…")
run_randomised_test_suite.randomize()
shared_lib.finish()
print("[INFO] Test run completed successfully — all assertions passed.")
